const translations = {
  ru: {
    title: "Prestige RolePlay",
    subtitle: "Форум",
    language: "Язык",
    themeToggle: "Тема",
    categories: "Категории",
    addCategory: "Добавить категорию",
    newCategory: "Новая категория",
    cancel: "Отмена",
    create: "Создать",
    threads: "Темы",
    back: "Назад",
    addThread: "Создать тему",
    newThread: "Новая тема",
    threadTitlePh: "Заголовок",
    threadContentPh: "Содержание",
    authorPh: "Автор",
    publish: "Опубликовать",
    posts: "Публикации",
    newPost: "Новая публикация",
    reply: "Ответить",
    captchaSolve: "Решите капчу",
    captchaRefresh: "Обновить",
    footer: "Prestige RolePlay • GTA RolePlay",
    empty: "Нет записей",
    threadsCount: "тем",
    postsCount: "постов",
    login: "Вход",
    register: "Регистрация",
    logout: "Выход",
    admin: "Админ",
    emailPh: "Email",
    usernamePh: "Имя пользователя",
    passwordPh: "Пароль",
    loginTitle: "Вход",
    registerTitle: "Регистрация",
    registerNote: "Проверьте почту для подтверждения регистрации",
    adminPanel: "Админ панел",
    adminCategories: "Категории",
    add: "Добавить",
    close: "Закрыть",
    categoryNamePh: "Название категории",
    apiError: "Ошибка API",
    adminOnly: "Только админ может добавлять категории"
    ,
    resetPassword: "Восстановление пароля",
    send: "Отправить",
    changePassword: "Смена пароля",
    tokenPh: "Токен",
    newPasswordPh: "Новый пароль",
    searchPh: "Поиск",
    search: "Поиск",
    prev: "Назад",
    next: "Вперед",
    edit: "Редактировать",
    delete: "Удалить",
    save: "Сохранить",
    editThread: "Редактирование темы",
    editPost: "Редактирование публикации",
    users: "Пользователи",
    ban: "Бан",
    unban: "Снять бан",
    setModerator: "Модератор",
    setUser: "Пользователь",
    setAdmin: "Назначить админа",
    lock: "Заблокировать",
    unlock: "Разблокировать",
    pin: "Закрепить",
    unpin: "Открепить",
    locked: "Заблокировано",
    likes: "Лайки",
    bannedLabel: "Забанен",
    profile: "Профиль",
    profileTitle: "Профиль",
    notifications: "Уведомления по email",
    tagsPh: "Теги (через запятую)",
    tagsEditPh: "Теги (через запятую)",
    copyright: "© {year} {brand}. Все права защищены.",
    adminDiagSMTP: "Диагностика SMTP",
    adminDiagDB: "Диагностика БД",
    dbLabel: "База данных",
    dbMySQL: "MySQL",
    dbJSON: "JSON",
    dbJSONFallback: "JSON (временный режим)"
    ,
    dbJSONWorkingNote: "Для ясности: база данных — JSON. Пишет, что отключена, но работает."
    ,
    resendConfirm: "Отправить повторно подтверждение",
    resendConfirmSent: "Письмо с подтверждением отправлено, если аккаунт не подтвержден",
    smtpDisabledNote: "SMTP не настроен: регистрация пройдет, но письмо не придет. После настройки используйте кнопку 'Отправить повторно подтверждение'."
    ,
    confirmEmail: "Подтвердить email",
    emailUnconfirmed: "email не подтвержден",
    twofa: "Двухфакторная защита",
    enable2fa: "Включить 2FA (Google Authenticator)",
    disable2fa: "Выключить 2FA",
    twofaSetupTitle: "Настройка 2FA",
    twofaScanNote: "Сканируйте QR в Google Authenticator или введите секрет вручную.",
    twofaCodePh: "TOTP код",
    twofaEnabledNote: "2FA включен",
    twofaRequired: "Требуется 2FA код"
  },
  kk: {
    title: "Prestige RolePlay",
    subtitle: "Форум",
    language: "Тіл",
    themeToggle: "Тема",
    categories: "Санаттар",
    addCategory: "Санат қосу",
    newCategory: "Жаңа санат",
    cancel: "Болдырмау",
    create: "Құру",
    threads: "Тақырыптар",
    back: "Артқа",
    addThread: "Тақырып құру",
    newThread: "Жаңа тақырып",
    threadTitlePh: "Тақырып",
    threadContentPh: "Мазмұн",
    authorPh: "Автор",
    publish: "Жариялау",
    posts: "Посттар",
    newPost: "Жаңа пост",
    reply: "Жауап беру",
    captchaSolve: "Капчаны шешіңіз",
    captchaRefresh: "Жаңарту",
    footer: "Prestige RolePlay • GTA RolePlay",
    empty: "Жазбалар жоқ",
    threadsCount: "тақырып",
    postsCount: "пост",
    login: "Кіру",
    register: "Тіркелу",
    logout: "Шығу",
    admin: "Әкімші",
    emailPh: "Email",
    usernamePh: "Пайдаланушы",
    passwordPh: "Құпиясөз",
    loginTitle: "Кіру",
    registerTitle: "Тіркелу",
    registerNote: "Растау үшін поштаны тексеріңіз",
    adminPanel: "Әкімші панелі",
    adminCategories: "Санаттар",
    add: "Қосу",
    close: "Жабу",
    categoryNamePh: "Санат атауы",
    apiError: "API қателігі",
    adminOnly: "Санатты тек әкімші қоса алады"
    ,
    resetPassword: "Құпиясөзді қалпына келтіру",
    send: "Жіберу",
    changePassword: "Құпиясөзді өзгерту",
    tokenPh: "Token",
    newPasswordPh: "Жаңа құпиясөз",
    searchPh: "Іздеу",
    search: "Іздеу",
    prev: "Артқа",
    next: "Алға",
    edit: "Өңдеу",
    delete: "Жою",
    save: "Сақтау",
    editThread: "Тақырыпты өңдеу",
    editPost: "Постты өңдеу",
    users: "Пайдаланушылар",
    ban: "Бан",
    unban: "Баннан алу",
    setModerator: "Модератор",
    setUser: "Пайдаланушы",
    setAdmin: "Админ ету",
    lock: "Блоктау",
    unlock: "Блоктан шығару",
    pin: "Бекіту",
    unpin: "Бекітуді алу",
    locked: "Блокталған",
    likes: "Лайк",
    bannedLabel: "Бан",
    profile: "Профиль",
    profileTitle: "Профиль",
    notifications: "Email хабарламалар",
    tagsPh: "Тегтер (үтірмен бөлінген)",
    tagsEditPh: "Тегтер (үтірмен бөлінген)",
    copyright: "© {year} {brand}. Барлық құқықтар қорғалған.",
    adminDiagSMTP: "SMTP диагностикасы",
    adminDiagDB: "DB диагностикасы",
    dbLabel: "Дерекқор",
    dbMySQL: "MySQL",
    dbJSON: "JSON",
    dbJSONFallback: "JSON (уақытша режим)"
    ,
    dbJSONWorkingNote: "Түсінікті болу үшін: дерекқор JSON. Өшірілген деп жазылғанымен, жұмыс істейді."
    ,
    resendConfirm: "Қайта растауды жіберу",
    resendConfirmSent: "Растау хаты жіберілді (егер аккаунт расталмаған болса)",
    smtpDisabledNote: "SMTP бапталмаған: тіркелу орындалады, бірақ хат келмейді. Баптаудан кейін 'Қайта растауды жіберу' түймесін қолданыңыз."
    ,
    confirmEmail: "Email-ді растау",
    emailUnconfirmed: "email расталмаған",
    twofa: "Екі факторлы қорғау",
    enable2fa: "2FA қосу (Google Authenticator)",
    disable2fa: "2FA болдырмау",
    twofaSetupTitle: "2FA баптау",
    twofaScanNote: "Google Authenticator-де QR скандеңіз немесе құпияны қолмен енгізіңіз.",
    twofaCodePh: "TOTP код",
    twofaEnabledNote: "2FA қосылған",
    twofaRequired: "2FA коды қажет"
  },
  uk: {
    title: "Prestige RolePlay",
    subtitle: "Форум",
    language: "Мова",
    themeToggle: "Тема",
    categories: "Категорії",
    addCategory: "Додати категорію",
    newCategory: "Нова категорія",
    cancel: "Скасувати",
    create: "Створити",
    threads: "Теми",
    back: "Назад",
    addThread: "Створити тему",
    newThread: "Нова тема",
    threadTitlePh: "Назва",
    threadContentPh: "Вміст",
    authorPh: "Автор",
    publish: "Опублікувати",
    posts: "Публікації",
    newPost: "Нова публікація",
    reply: "Відповісти",
    captchaSolve: "Розв'яжіть капчу",
    captchaRefresh: "Оновити",
    footer: "Prestige RolePlay • GTA RolePlay",
    empty: "Немає записів",
    threadsCount: "тем",
    postsCount: "постів",
    login: "Вхід",
    register: "Реєстрація",
    logout: "Вихід",
    admin: "Адмін",
    emailPh: "Email",
    usernamePh: "Користувач",
    passwordPh: "Пароль",
    loginTitle: "Вхід",
    registerTitle: "Реєстрація",
    registerNote: "Перевірте пошту для підтвердження",
    adminPanel: "Адмін панель",
    adminCategories: "Категорії",
    add: "Додати",
    close: "Закрити",
    categoryNamePh: "Назва категорії",
    apiError: "Помилка API",
    adminOnly: "Лише адмін може додавати категорії"
    ,
    resetPassword: "Відновлення пароля",
    send: "Надіслати",
    changePassword: "Зміна пароля",
    tokenPh: "Token",
    newPasswordPh: "Новий пароль",
    searchPh: "Пошук",
    search: "Пошук",
    prev: "Назад",
    next: "Вперед",
    edit: "Редагувати",
    delete: "Видалити",
    save: "Зберегти",
    editThread: "Редагування теми",
    editPost: "Редагування публікації",
    users: "Користувачі",
    ban: "Бан",
    unban: "Зняти бан",
    setModerator: "Модератор",
    setUser: "Користувач",
    lock: "Заблокувати",
    unlock: "Розблокувати",
    pin: "Закріпити",
    unpin: "Відкріпити",
    locked: "Заблоковано",
    likes: "Лайки",
    profile: "Профіль",
    profileTitle: "Профіль",
    notifications: "Email сповіщення",
    tagsPh: "Теги (через кому)",
    tagsEditPh: "Теги (через кому)",
    copyright: "© {year} {brand}. Усі права захищені.",
    adminDiagSMTP: "Діагностика SMTP",
    adminDiagDB: "Діагностика БД",
    dbLabel: "База даних",
    dbMySQL: "MySQL",
    dbJSON: "JSON",
    dbJSONFallback: "JSON (тимчасовий режим)"
    ,
    dbJSONWorkingNote: "Для ясності: база даних — JSON. Пише, що вимкнена, але працює."
    ,
    resendConfirm: "Надіслати повторне підтвердження",
    resendConfirmSent: "Лист підтвердження надіслано, якщо акаунт не підтверджений",
    smtpDisabledNote: "SMTP не налаштовано: реєстрація пройде, але лист не прийде. Після налаштування використовуйте 'Надіслати повторне підтвердження'."
    ,
    confirmEmail: "Підтвердити email",
    emailUnconfirmed: "email не підтверджено",
    twofa: "Двофакторний захист",
    enable2fa: "Увімкнути 2FA (Google Authenticator)",
    disable2fa: "Вимкнути 2FA",
    twofaSetupTitle: "Налаштування 2FA",
    twofaScanNote: "Скануйте QR у Google Authenticator або введіть секрет вручну.",
    twofaCodePh: "TOTP код",
    twofaEnabledNote: "2FA увімкнено",
    twofaRequired: "Потрібен 2FA код"
  },
  bg: {
    title: "Prestige RolePlay",
    subtitle: "Форум",
    language: "Език",
    themeToggle: "Тема",
    categories: "Категории",
    addCategory: "Добави категория",
    newCategory: "Нова категория",
    cancel: "Отказ",
    create: "Създай",
    threads: "Теми",
    back: "Назад",
    addThread: "Създай тема",
    newThread: "Нова тема",
    threadTitlePh: "Заглавие",
    threadContentPh: "Съдържание",
    authorPh: "Автор",
    publish: "Публикувай",
    posts: "Публикации",
    newPost: "Нова публикация",
    reply: "Отговори",
    captchaSolve: "Решете CAPTCHA",
    captchaRefresh: "Обнови",
    footer: "Prestige RolePlay • GTA RolePlay",
    empty: "Няма записи",
    threadsCount: "теми",
    postsCount: "постове",
    login: "Вход",
    register: "Регистрация",
    logout: "Изход",
    admin: "Админ",
    emailPh: "Email",
    usernamePh: "Потребител",
    passwordPh: "Парола",
    loginTitle: "Вход",
    registerTitle: "Регистрация",
    registerNote: "Провери имейла за потвърждение",
    adminPanel: "Админ панел",
    adminCategories: "Категории",
    add: "Добави",
    close: "Затвори",
    categoryNamePh: "Име на категория",
    apiError: "API грешка",
    adminOnly: "Само админ може да добавя категории"
    ,
    resetPassword: "Възстановяване на парола",
    send: "Изпрати",
    changePassword: "Смяна на парола",
    tokenPh: "Token",
    newPasswordPh: "Нова парола",
    searchPh: "Търсене",
    search: "Търси",
    prev: "Назад",
    next: "Напред",
    edit: "Редакция",
    delete: "Изтриване",
    save: "Запази",
    editThread: "Редакция на тема",
    editPost: "Редакция на публикация",
    users: "Потребители",
    ban: "Бан",
    unban: "Премахни бан",
    setModerator: "Назначи модератор",
    setUser: "Назначи потребител",
    setAdmin: "Назначи администратор",
    lock: "Заключи",
    unlock: "Отключи",
    pin: "Закачи",
    unpin: "Откачи",
    locked: "Заключено",
    likes: "Харесвания",
    bannedLabel: "Блокиран",
    profile: "Профил",
    profileTitle: "Профил",
    notifications: "Уведомления по имейл",
    tagsPh: "Тагове (разделени със запетая)",
    tagsEditPh: "Тагове (разделени със запетая)",
    copyright: "© {year} {brand}. Всички права запазени.",
    adminDiagSMTP: "Диагностика на SMTP",
    adminDiagDB: "Диагностика на база данни",
    dbLabel: "База данни",
    dbMySQL: "MySQL",
    dbJSON: "JSON",
    dbJSONFallback: "JSON (временен режим)"
    ,
    dbJSONWorkingNote: "За яснота: Базата данни е JSON. Пише, че е изключена, но работи."
    ,
    resendConfirm: "Изпрати наново потвърждение",
    resendConfirmSent: "Изпратихме потвърждение, ако акаунтът не е потвърден",
    smtpDisabledNote: "SMTP не е конфигуриран: Регистрацията ще мине, но няма да получиш имейл. След конфигуриране използвай 'Изпрати наново потвърждение'."
    ,
    confirmEmail: "Потвърди имейл",
    emailUnconfirmed: "имейл не е потвърден",
    twofa: "Двуфакторна защита",
    enable2fa: "Включи 2FA (Google Authenticator)",
    disable2fa: "Изключи 2FA",
    twofaSetupTitle: "Настройка на 2FA",
    twofaScanNote: "Сканирай QR в Google Authenticator или въведи секретния ключ ръчно.",
    twofaCodePh: "TOTP код",
    twofaEnabledNote: "2FA е включен",
    twofaRequired: "Изисква се 2FA код"
    ,
    logoutAll: "Изход от всички устройства"
    ,
    newPostInThread: "Нов пост в тема: {title}"
  },
  en: {
    title: "Prestige RolePlay",
    subtitle: "Forum",
    language: "Language",
    themeToggle: "Theme",
    categories: "Categories",
    addCategory: "Add Category",
    newCategory: "New Category",
    cancel: "Cancel",
    create: "Create",
    threads: "Threads",
    back: "Back",
    addThread: "Create Thread",
    newThread: "New Thread",
    threadTitlePh: "Title",
    threadContentPh: "Content",
    authorPh: "Author",
    publish: "Publish",
    posts: "Posts",
    newPost: "New Post",
    reply: "Reply",
    captchaSolve: "Solve CAPTCHA",
    captchaRefresh: "Refresh",
    footer: "Prestige RolePlay • GTA RolePlay",
    empty: "No records",
    threadsCount: "threads",
    postsCount: "posts",
    login: "Login",
    register: "Register",
    logout: "Logout",
    admin: "Admin",
    emailPh: "Email",
    usernamePh: "Username",
    passwordPh: "Password",
    loginTitle: "Login",
    registerTitle: "Register",
    registerNote: "Check email to confirm registration",
    adminPanel: "Admin Panel",
    adminCategories: "Categories",
    add: "Add",
    close: "Close",
    categoryNamePh: "Category name",
    apiError: "API error",
    adminOnly: "Only admin can add categories"
    ,
    resetPassword: "Password reset",
    send: "Send",
    changePassword: "Change password",
    tokenPh: "Token",
    newPasswordPh: "New password",
    searchPh: "Search",
    search: "Search",
    prev: "Prev",
    next: "Next",
    edit: "Edit",
    delete: "Delete",
    save: "Save",
    editThread: "Edit thread",
    editPost: "Edit post",
    users: "Users",
    ban: "Ban",
    unban: "Unban",
    setModerator: "Moderator",
    setUser: "User",
    setAdmin: "Make Admin",
    lock: "Lock",
    unlock: "Unlock",
    pin: "Pin",
    unpin: "Unpin",
    locked: "Locked",
    likes: "Likes",
    bannedLabel: "BANNED",
    profile: "Profile",
    profileTitle: "Profile",
    notifications: "Email notifications",
    tagsPh: "Tags (comma-separated)",
    tagsEditPh: "Tags (comma-separated)",
    copyright: "© {year} {brand}. All rights reserved.",
    adminDiagSMTP: "SMTP Diagnostics",
    adminDiagDB: "DB Diagnostics",
    dbLabel: "Database",
    dbMySQL: "MySQL",
    dbJSON: "JSON",
    dbJSONFallback: "JSON (fallback)"
    ,
    dbJSONWorkingNote: "For clarity: the database is JSON. It says it's disabled, but it works."
    ,
    resendConfirm: "Resend confirmation",
    resendConfirmSent: "Confirmation email sent if the account is unconfirmed",
    smtpDisabledNote: "SMTP is not configured: registration works, but no email will arrive. After configuring, use 'Resend confirmation'."
    ,
    confirmEmail: "Confirm email",
    emailUnconfirmed: "email unconfirmed",
    twofa: "Two-factor auth",
    enable2fa: "Enable 2FA (Google Authenticator)",
    disable2fa: "Disable 2FA",
    twofaSetupTitle: "2FA Setup",
    twofaScanNote: "Scan QR in Google Authenticator or enter the secret manually.",
    twofaCodePh: "TOTP code",
    twofaEnabledNote: "2FA is enabled",
    twofaRequired: "2FA code required"
    ,
    logoutAll: "Logout all devices"
    ,
    newPostInThread: "New post in thread: {title}"
  }
};

const api = {
  base: (typeof window !== "undefined" && (window.API_BASE || new URLSearchParams(window.location.search).get("apiBase") || (document.querySelector('meta[name="api-base"]') && document.querySelector('meta[name="api-base"]').content))) || "",
  token: localStorage.getItem("auth_token") || "",
  refreshToken: localStorage.getItem("refresh_token") || "",
  setToken(t) { this.token = t; if (t) localStorage.setItem("auth_token", t); else localStorage.removeItem("auth_token"); },
  setRefreshToken(t) { this.refreshToken = t || ""; if (t) localStorage.setItem("refresh_token", t); else localStorage.removeItem("refresh_token"); },
  async refresh() {
    if (!this.refreshToken) { this.setToken(""); return false; }
    try {
      const url = this.base ? `${this.base}/api/auth/refresh` : "/api/auth/refresh";
      const r = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ refresh_token: this.refreshToken }) });
      if (!r.ok) return false;
      const data = await r.json();
      if (data && data.token) this.setToken(data.token);
      if (data && data.refresh_token) this.setRefreshToken(data.refresh_token);
      return !!(data && data.token);
    } catch { return false; }
  },
  async get(path) {
    const url = this.base ? `${this.base}${path}` : path;
    let r = await fetch(url, { headers: this.token ? { Authorization: `Bearer ${this.token}` } : {} });
    if (r.status === 401) {
      const ok = await this.refresh();
      if (ok) r = await fetch(url, { headers: this.token ? { Authorization: `Bearer ${this.token}` } : {} });
    }
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  },
  async post(path, body) {
    const url = this.base ? `${this.base}${path}` : path;
    let r = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json", ...(this.token ? { Authorization: `Bearer ${this.token}` } : {}) },
      body: JSON.stringify(body)
    });
    if (r.status === 401) {
      const ok = await this.refresh();
      if (ok) {
        r = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", ...(this.token ? { Authorization: `Bearer ${this.token}` } : {}) },
          body: JSON.stringify(body)
        });
      }
    }
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  }
};
// Normalize base if a stale localhost leaked into client while page runs on non-localhost
if (typeof window !== "undefined") {
  try {
    const host = window.location && window.location.hostname;
    if (/localhost|127\.0\.0\.1/.test(api.base) && host && !/localhost|127\.0\.0\.1/.test(host)) {
      api.base = "";
    }
  } catch {}
}

const store = {
  pendingAttachments: [],
  async categories() {
    return api.get("/api/categories");
  },
  async addCategory(name) {
    return api.post("/api/categories", { name });
  },
  async threadsByCategory(categoryId) {
    return api.get(`/api/categories/${categoryId}/threads`);
  },
  async addThread(categoryId, title, content) {
    return api.post("/api/threads", { categoryId, title, content });
  },
  async postsByThread(threadId) {
    return api.get(`/api/threads/${threadId}/posts`);
  },
  async addPost(threadId, content) {
    const res = await api.post("/api/posts", { threadId, content, attachments: this.pendingAttachments || [] });
    this.pendingAttachments = [];
    return res;
  }
};

const ui = {
  state: { lang: "ru", theme: "dark", current: { categoryId: null, threadId: null }, user: null },
  t(k) {
    const cur = translations[this.state.lang] || translations.ru;
    return (cur && cur[k] !== undefined) ? cur[k] : (translations.ru[k] !== undefined ? translations.ru[k] : k);
  },
  el: {},
  init() {
    this.cache();
    this.bind();
    this.applyLang();
    this.refreshMeta();
    this.restoreAuth();
    this.connectWs();
    this.renderCategories();
  },
  cache() {
    this.el.title = document.getElementById("title");
    this.el.subtitle = document.getElementById("subtitle");
    this.el.langLabel = document.getElementById("langLabel");
    this.el.lang = document.getElementById("lang");
    this.el.themeToggle = document.getElementById("themeToggle");
    this.el.controls = document.getElementById("controls");
    this.el.burgerBtn = document.getElementById("burgerBtn");
    this.el.loginBtn = document.getElementById("loginBtn");
    this.el.registerBtn = document.getElementById("registerBtn");
    this.el.userBadge = document.getElementById("userBadge");
    this.el.logoutBtn = document.getElementById("logoutBtn");
    this.el.adminBtn = document.getElementById("adminBtn");
    this.el.profileBtn = document.getElementById("profileBtn");
    this.el.profileDialog = document.getElementById("profileDialog");
    this.el.profileForm = document.getElementById("profileForm");
    this.el.profileTitle = document.getElementById("profileTitle");
    this.el.profileUsername = document.getElementById("profileUsername");
    this.el.profileNotifications = document.getElementById("profileNotifications");
    this.el.profileNotificationsLabel = document.getElementById("profileNotificationsLabel");
    this.el.avatarUpload = document.getElementById("avatarUpload");
    this.el.enable2faBtn = document.getElementById("enable2faBtn");
    this.el.disable2faBtn = document.getElementById("disable2faBtn");
    this.el.logoutAllBtn = document.getElementById("logoutAllBtn");
    this.el.twofaDialog = document.getElementById("twofaDialog");
    this.el.twofaForm = document.getElementById("twofaForm");
    this.el.twofaTitle = document.getElementById("twofaTitle");
    this.el.twofaNote = document.getElementById("twofaNote");
    this.el.twofaSecret = document.getElementById("twofaSecret");
    this.el.twofaUri = document.getElementById("twofaUri");
    this.el.twofaCode = document.getElementById("twofaCode");
    this.el.twofaCancel = document.getElementById("twofaCancel");
    this.el.twofaActivate = document.getElementById("twofaActivate");
    this.el.profileCancel = document.getElementById("profileCancel");
    this.el.saveProfile = document.getElementById("saveProfile");
    this.el.loginDialog = document.getElementById("loginDialog");
    this.el.loginForm = document.getElementById("loginForm");
    this.el.loginCaptcha = document.getElementById("loginCaptcha");
    this.el.loginNote = document.getElementById("loginNote");
    this.el.loginTitle = document.getElementById("loginTitle");
    this.el.loginEmail = document.getElementById("loginEmail");
    this.el.loginPassword = document.getElementById("loginPassword");
    this.el.loginTotp = document.getElementById("loginTotp");
    this.el.loginCancel = document.getElementById("loginCancel");
    this.el.loginResendBtn = document.getElementById("loginResendBtn");
    this.el.loginSubmit = document.getElementById("loginSubmit");
    this.el.registerDialog = document.getElementById("registerDialog");
    this.el.registerForm = document.getElementById("registerForm");
    this.el.registerCaptcha = document.getElementById("registerCaptcha");
    this.el.registerTitle = document.getElementById("registerTitle");
    this.el.registerEmail = document.getElementById("registerEmail");
    this.el.registerUsername = document.getElementById("registerUsername");
    this.el.registerPassword = document.getElementById("registerPassword");
    this.el.registerCancel = document.getElementById("registerCancel");
    this.el.registerSubmit = document.getElementById("registerSubmit");
    this.el.registerNote = document.getElementById("registerNote");
    this.el.resetDialog = document.getElementById("resetDialog");
    this.el.resetForm = document.getElementById("resetForm");
    this.el.resetTitle = document.getElementById("resetTitle");
    this.el.resetEmail = document.getElementById("resetEmail");
    this.el.resetCancel = document.getElementById("resetCancel");
    this.el.resetSubmit = document.getElementById("resetSubmit");
    this.el.resetNote = document.getElementById("resetNote");
    this.el.performResetDialog = document.getElementById("performResetDialog");
    this.el.performResetForm = document.getElementById("performResetForm");
    this.el.performResetTitle = document.getElementById("performResetTitle");
    this.el.performResetToken = document.getElementById("performResetToken");
    this.el.performResetPassword = document.getElementById("performResetPassword");
    this.el.performResetCancel = document.getElementById("performResetCancel");
    this.el.performResetSubmit = document.getElementById("performResetSubmit");
    this.el.categoriesTitle = document.getElementById("categoriesTitle");
    this.el.addCategoryBtn = document.getElementById("addCategoryBtn");
    this.el.categoryList = document.getElementById("categoryList");
    this.el.categoryDialog = document.getElementById("categoryDialog");
    this.el.categoryForm = document.getElementById("categoryForm");
    this.el.categoryNameInput = document.getElementById("categoryNameInput");
    this.el.categoryDialogTitle = document.getElementById("categoryDialogTitle");
    this.el.cancelLabel = document.getElementById("cancelLabel");
    this.el.createLabel = document.getElementById("createLabel");
    this.el.cancelLabel2 = document.getElementById("cancelLabel2");
    this.el.publishLabel = document.getElementById("publishLabel");
    this.el.viewCategories = document.getElementById("view-categories");
    this.el.viewThreads = document.getElementById("view-threads");
    this.el.viewPosts = document.getElementById("view-posts");
    this.el.threadsTitle = document.getElementById("threadsTitle");
    this.el.backToCategories = document.getElementById("backToCategories");
    this.el.addThreadBtn = document.getElementById("addThreadBtn");
    this.el.searchInput = document.getElementById("searchInput");
    this.el.searchBtn = document.getElementById("searchBtn");
    this.el.searchMeta = document.getElementById("searchMeta");
    this.el.threadList = document.getElementById("threadList");
    this.el.threadDialog = document.getElementById("threadDialog");
    this.el.threadForm = document.getElementById("threadForm");
    this.el.threadDialogTitle = document.getElementById("threadDialogTitle");
    this.el.threadTitleInput = document.getElementById("threadTitleInput");
    this.el.threadContentInput = document.getElementById("threadContentInput");
    this.el.threadTagsInput = document.getElementById("threadTagsInput");
    this.el.threadAuthorInput = document.getElementById("threadAuthorInput");
    this.el.threadCaptcha = null;
    this.el.editThreadDialog = document.getElementById("editThreadDialog");
    this.el.editThreadForm = document.getElementById("editThreadForm");
    this.el.editThreadTitle = document.getElementById("editThreadTitle");
    this.el.editThreadTitleInput = document.getElementById("editThreadTitleInput");
    this.el.editThreadTagsInput = document.getElementById("editThreadTagsInput");
    this.el.editThreadCancel = document.getElementById("editThreadCancel");
    this.el.editThreadSubmit = document.getElementById("editThreadSubmit");
    this.el.threadsPrev = document.getElementById("threadsPrev");
    this.el.threadsNext = document.getElementById("threadsNext");
    this.el.postsTitle = document.getElementById("postsTitle");
    this.el.backToThreads = document.getElementById("backToThreads");
    this.el.addPostBtn = document.getElementById("addPostBtn");
    this.el.postList = document.getElementById("postList");
    this.el.postDialog = document.getElementById("postDialog");
    this.el.postForm = document.getElementById("postForm");
    this.el.postDialogTitle = document.getElementById("postDialogTitle");
    this.el.postContentInput = document.getElementById("postContentInput");
    this.el.postCaptcha = null;
    this.el.cancelLabel3 = document.getElementById("cancelLabel3");
    this.el.replyLabel = document.getElementById("replyLabel");
    this.el.postsPrev = document.getElementById("postsPrev");
    this.el.postsNext = document.getElementById("postsNext");
    this.el.editPostDialog = document.getElementById("editPostDialog");
    this.el.editPostForm = document.getElementById("editPostForm");
    this.el.editPostTitle = document.getElementById("editPostTitle");
    this.el.editPostContentInput = document.getElementById("editPostContentInput");
    this.el.editPostCancel = document.getElementById("editPostCancel");
    this.el.editPostSubmit = document.getElementById("editPostSubmit");
    this.el.threadMeta = document.getElementById("threadMeta");
    this.el.footerText = document.getElementById("footerText");
    this.el.copyrightText = document.getElementById("copyrightText");
    this.el.viewAdmin = document.getElementById("view-admin");
    this.el.adminTitle = document.getElementById("adminTitle");
    this.el.backAdminClose = document.getElementById("backAdminClose");
    this.el.adminMeta = document.getElementById("adminMeta");
    this.el.adminCategoriesTitle = document.getElementById("adminCategoriesTitle");
    this.el.adminCategoryName = document.getElementById("adminCategoryName");
    this.el.adminAddCategory = document.getElementById("adminAddCategory");
    this.el.adminCategoryList = document.getElementById("adminCategoryList");
    this.el.adminUsersTitle = document.getElementById("adminUsersTitle");
    this.el.adminUserList = document.getElementById("adminUserList");
    this.el.dbBadge = document.getElementById("dbBadge");
    this.el.adminDiagSMTPBtn = document.getElementById("adminDiagSMTPBtn");
    this.el.adminDiagDBBtn = document.getElementById("adminDiagDBBtn");
  },
  bind() {
    this.el.lang.addEventListener("change", () => {
      this.state.lang = this.el.lang.value;
      document.documentElement.lang = this.state.lang;
      this.applyLang();
      this.render();
    });
    this.el.themeToggle.addEventListener("click", () => {
      this.state.theme = this.state.theme === "dark" ? "light" : "dark";
      document.body.dataset.theme = this.state.theme;
      this.el.themeToggle.textContent = this.state.theme === "dark" ? "☾" : "☼";
    });
    if (this.el.burgerBtn) {
      this.el.burgerBtn.addEventListener("click", () => {
        this.el.controls.classList.toggle("open");
      });
    }
    this.el.loginBtn.addEventListener("click", () => { this.el.loginDialog.showModal(); captcha.mount(this.el.loginCaptcha, () => {}); });
    this.el.registerBtn.addEventListener("click", () => { this.el.registerDialog.showModal(); captcha.mount(this.el.registerCaptcha, () => {}); });
    this.el.profileBtn.addEventListener("click", () => {
      if (!this.state.user) return;
      this.el.profileUsername.value = this.state.user.username || "";
      this.el.profileNotifications.checked = !!this.state.user.notifications;
      this.el.profileDialog.showModal();
    });
    this.el.loginCancel.addEventListener("click", (e) => { e.preventDefault(); this.el.loginDialog.close(); });
    this.el.registerCancel.addEventListener("click", (e) => { e.preventDefault(); this.el.registerDialog.close(); });
    this.el.profileCancel.addEventListener("click", (e) => { e.preventDefault(); this.el.profileDialog.close(); });
    this.el.profileForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        const id = this.state.user?.id;
        if (!id) return;
        const file = this.el.avatarUpload.files?.[0];
        if (file) {
          const fd = new FormData();
          fd.append("avatar", file);
          const r = await fetch(`${api.base}/api/users/${id}/avatar`, { method: "POST", headers: { Authorization: `Bearer ${api.token}` }, body: fd });
          if (!r.ok) throw new Error(await r.text());
          const j = await r.json();
          if (j.avatar_url) this.state.user.avatar_url = j.avatar_url;
        }
        await api.post(`/api/users/${id}/profile`, { username: this.el.profileUsername.value.trim(), notifications: !!this.el.profileNotifications.checked });
        this.el.profileDialog.close();
        this.updateHeaderAuth();
      } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
    });
    if (this.el.enable2faBtn) {
      this.el.enable2faBtn.addEventListener("click", async () => {
        try {
          if (!this.state.user) return;
          const r = await api.post("/api/auth/2fa/setup", {});
          this.el.twofaTitle.textContent = this.t("twofaSetupTitle");
          this.el.twofaNote.textContent = this.t("twofaScanNote");
          this.el.twofaSecret.textContent = `Secret: ${r.secret}`;
          this.el.twofaUri.textContent = `URI: ${r.uri}`;
          this.el.twofaCode.value = "";
          this.el.twofaDialog.showModal();
          this.el.twofaForm.onsubmit = async (e2) => {
            e2.preventDefault();
            try {
              await api.post("/api/auth/2fa/activate", { code: this.el.twofaCode.value.trim() });
              this.el.twofaDialog.close();
              alert(this.t("twofaEnabledNote"));
            } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
          };
          this.el.twofaCancel.onclick = () => this.el.twofaDialog.close();
        } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
      });
    }
    if (this.el.disable2faBtn) {
      this.el.disable2faBtn.addEventListener("click", async () => {
        try {
          this.el.twofaTitle.textContent = this.t("disable2fa");
          this.el.twofaNote.textContent = this.t("twofaRequired");
          this.el.twofaSecret.textContent = "";
          this.el.twofaUri.textContent = "";
          this.el.twofaCode.value = "";
          this.el.twofaDialog.showModal();
          this.el.twofaForm.onsubmit = async (e2) => {
            e2.preventDefault();
            try {
              await api.post("/api/auth/2fa/disable", { code: this.el.twofaCode.value.trim() });
              this.el.twofaDialog.close();
              alert("OK");
            } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
          };
          this.el.twofaCancel.onclick = () => this.el.twofaDialog.close();
        } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
      });
    }
    if (this.el.logoutAllBtn) {
      this.el.logoutAllBtn.addEventListener("click", async () => {
        try {
          await api.post("/api/auth/logout_all", {});
        } catch {}
        api.setToken("");
        api.setRefreshToken("");
        this.state.user = null;
        this.updateHeaderAuth();
        this.render();
        this.el.profileDialog.close();
      });
    }
    this.el.cancelLabel.addEventListener("click", (e) => { e.preventDefault(); this.el.categoryDialog.close(); });
    this.el.cancelLabel2.addEventListener("click", (e) => { e.preventDefault(); this.el.threadDialog.close(); });
    this.el.cancelLabel3.addEventListener("click", (e) => { e.preventDefault(); this.el.postDialog.close(); });
    const forgotLink = document.createElement("button");
    forgotLink.className = "ghost";
    forgotLink.textContent = this.t("resetPassword");
    forgotLink.addEventListener("click", () => this.el.resetDialog.showModal());
    this.el.loginForm.appendChild(forgotLink);
    this.el.resetCancel.addEventListener("click", (e) => { e.preventDefault(); this.el.resetDialog.close(); });
    this.el.performResetCancel.addEventListener("click", (e) => { e.preventDefault(); this.el.performResetDialog.close(); });
    this.el.logoutBtn.addEventListener("click", () => {
      api.setToken("");
      api.setRefreshToken("");
      this.state.user = null;
      this.updateHeaderAuth();
      this.render();
    });
    this.el.loginForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        if (!captcha.verify(this.el.loginCaptcha)) return;
        const r = await api.post("/api/auth/login", { email: this.el.loginEmail.value.trim(), password: this.el.loginPassword.value, totp: (this.el.loginTotp?.value || "").trim() || undefined });
        api.setToken(r.token);
        if (r.refresh_token) api.setRefreshToken(r.refresh_token);
        this.state.user = r.user;
        this.el.loginDialog.close();
        this.updateHeaderAuth();
        this.render();
        if (r.require_twofa_prompt) {
          try {
            const setup = await api.post("/api/auth/2fa/setup", {});
            this.el.twofaTitle.textContent = this.t("twofaSetupTitle");
            this.el.twofaNote.textContent = this.t("twofaScanNote");
            this.el.twofaSecret.textContent = `Secret: ${setup.secret}`;
            this.el.twofaUri.textContent = `URI: ${setup.uri}`;
            this.el.twofaCode.value = "";
            this.el.twofaDialog.showModal();
            const onCancel = async () => {
              try { await api.post("/api/auth/2fa/skip", {}); } catch {}
              this.el.twofaDialog.close();
            };
            this.el.twofaCancel.onclick = onCancel;
            this.el.twofaForm.onsubmit = async (e2) => {
              e2.preventDefault();
              try {
                await api.post("/api/auth/2fa/activate", { code: this.el.twofaCode.value.trim() });
                this.el.twofaDialog.close();
                alert(this.t("twofaEnabledNote"));
              } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
            };
          } catch {}
        }
      } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
    });
    this.el.registerForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        if (!captcha.verify(this.el.registerCaptcha)) return;
        const r = await api.post("/api/auth/register", {
          email: this.el.registerEmail.value.trim(),
          username: this.el.registerUsername.value.trim(),
          password: this.el.registerPassword.value,
          locale: this.state.lang
        });
        this.el.registerNote.textContent = (r && r.smtp_ready) ? this.t("registerNote") : this.t("smtpDisabledNote");
      } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
    });
    this.el.resetForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        await api.post("/api/auth/reset/request", { email: this.el.resetEmail.value.trim() });
        this.el.resetNote.textContent = this.t("registerNote");
      } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
    });
    this.el.performResetForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        await api.post("/api/auth/reset/perform", { token: this.el.performResetToken.value.trim(), password: this.el.performResetPassword.value });
        this.el.performResetDialog.close();
        alert("OK");
      } catch (err) { alert(ui.t("apiError") + ": " + err.message) }
    });
    this.el.addCategoryBtn.addEventListener("click", () => this.el.categoryDialog.showModal());
    this.el.categoryForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const name = this.el.categoryNameInput.value.trim();
      if (!name) return;
      if (!this.state.user || this.state.user.role !== "admin") { alert(ui.t("adminOnly")); return }
      store.addCategory(name).then(() => {
        this.el.categoryNameInput.value = "";
        this.el.categoryDialog.close();
        this.renderCategories();
      }).catch(err => alert(ui.t("apiError") + ": " + err.message));
    });
    this.el.backToCategories.addEventListener("click", () => {
      this.state.current.categoryId = null;
      this.show("categories");
      this.renderCategories();
    });
    this.el.addThreadBtn.addEventListener("click", () => {
      if (!this.state.user) { this.el.loginDialog.showModal(); return }
      this.el.threadDialog.showModal();
    });
    this.el.threadForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const title = this.el.threadTitleInput.value.trim();
      const content = this.el.threadContentInput.value.trim();
      if (!title || !content) return;
      store.addThread(this.state.current.categoryId, title, content)
        .then(t => {
          const tagsRaw = (this.el.threadTagsInput?.value || "").trim();
          if (tagsRaw) {
            const tags = tagsRaw.split(",").map(s => s.trim()).filter(Boolean);
            api.post(`/api/threads/${t.id}/edit`, { tags }).catch(()=>{});
          }
          this.el.threadTitleInput.value = "";
          this.el.threadContentInput.value = "";
          if (this.el.threadTagsInput) this.el.threadTagsInput.value = "";
          this.el.threadDialog.close();
          this.renderThreads(this.state.current.categoryId);
          this.openThread(t.id);
        })
        .catch(err => alert(ui.t("apiError") + ": " + err.message));
    });
    this.el.searchBtn.addEventListener("click", () => {
      this.state.searchPage = 1;
      this.renderThreads(this.state.current.categoryId);
    });
    this.el.threadsPrev.addEventListener("click", () => {
      this.state.searchPage = Math.max(1, (this.state.searchPage || 1) - 1);
      this.renderThreads(this.state.current.categoryId);
    });
    this.el.threadsNext.addEventListener("click", () => {
      this.state.searchPage = (this.state.searchPage || 1) + 1;
      this.renderThreads(this.state.current.categoryId);
    });
    this.el.backToThreads.addEventListener("click", () => {
      this.state.current.threadId = null;
      this.show("threads");
      this.renderThreads(this.state.current.categoryId);
    });
    this.el.addPostBtn.addEventListener("click", () => {
      if (!this.state.user) { this.el.loginDialog.showModal(); return }
      this.el.postDialog.showModal();
    });
    const filesInput = document.getElementById("postFiles");
    if (filesInput) {
      filesInput.addEventListener("change", async () => {
        const f = filesInput.files;
        if (!f || !f.length) { store.pendingAttachments = []; return }
        const fd = new FormData();
        for (let i = 0; i < Math.min(4, f.length); i++) fd.append("files", f[i]);
        const r = await fetch(`${api.base}/api/upload`, { method: "POST", headers: { Authorization: `Bearer ${api.token}` }, body: fd });
        if (!r.ok) { alert(ui.t("apiError")); return }
        const j = await r.json();
        store.pendingAttachments = j.files;
      });
    }
    this.el.postForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const content = this.el.postContentInput.value.trim();
      if (!content) return;
      store.addPost(this.state.current.threadId, content)
        .then(() => {
          this.el.postContentInput.value = "";
          this.el.postDialog.close();
          this.renderPosts(this.state.current.threadId);
        })
        .catch(err => alert(ui.t("apiError") + ": " + err.message));
    });
    this.el.postsPrev.addEventListener("click", () => {
      this.state.postsPage = Math.max(1, (this.state.postsPage || 1) - 1);
      this.renderPosts(this.state.current.threadId);
    });
    this.el.postsNext.addEventListener("click", () => {
      this.state.postsPage = (this.state.postsPage || 1) + 1;
      this.renderPosts(this.state.current.threadId);
    });
    this.el.adminBtn.addEventListener("click", () => {
      if (this.state.user?.role !== "admin") return;
      this.show("admin");
      this.refreshMeta();
      this.renderAdmin();
    });
    this.el.backAdminClose.addEventListener("click", () => {
      this.show("categories");
    });
    if (this.el.adminDiagSMTPBtn) {
      this.el.adminDiagSMTPBtn.addEventListener("click", async () => {
        try {
          const r = await api.post("/api/diag/smtp", {});
          this.el.adminMeta.textContent = `SMTP: OK • изпратено до ${r.sent_to}`;
        } catch (err) {
          this.el.adminMeta.textContent = `SMTP грешка: ${err.message}`;
        }
      });
    }
    if (this.el.loginResendBtn) {
      this.el.loginResendBtn.addEventListener("click", async () => {
        const email = this.el.loginEmail.value.trim();
        if (!email) { alert(this.t("emailPh")); return }
        this.el.loginResendBtn.disabled = true;
        try {
          await api.post("/api/auth/resend-confirm", { email });
          if (this.el.loginNote) this.el.loginNote.textContent = this.t("resendConfirmSent");
        } catch (err) {
          if (this.el.loginNote) this.el.loginNote.textContent = `${this.t("apiError")}: ${err.message}`;
        } finally {
          this.el.loginResendBtn.disabled = false;
        }
      });
    }
    if (this.el.adminDiagDBBtn) {
      this.el.adminDiagDBBtn.addEventListener("click", async () => {
        try {
          const r = await api.post("/api/diag/mysql", {});
          if (r.ok && r.ready) {
            this.el.adminMeta.textContent = `DB: OK • MySQL ${r.host}:${r.port}/${r.db}`;
          } else {
            this.el.adminMeta.textContent = `DB: неактивна • ${r.error || "unknown"}`;
          }
        } catch (err) {
          this.el.adminMeta.textContent = `DB грешка: ${err.message}`;
        }
      });
    }
  },
  applyLang() {
    this.el.title.textContent = this.t("title");
    this.el.subtitle.textContent = this.t("subtitle");
    this.el.langLabel.textContent = this.t("language");
    this.el.themeToggle.textContent = "☾";
    if (this.el.burgerBtn) this.el.burgerBtn.textContent = "☰";
    this.el.loginBtn.textContent = this.t("login");
    this.el.registerBtn.textContent = this.t("register");
    this.el.logoutBtn.textContent = this.t("logout");
    this.el.adminBtn.textContent = this.t("admin");
    this.el.profileBtn.textContent = this.t("profile");
    this.el.categoriesTitle.textContent = this.t("categories");
    this.el.addCategoryBtn.textContent = this.t("addCategory");
    this.el.categoryDialogTitle.textContent = this.t("newCategory");
    this.el.cancelLabel.textContent = this.t("cancel");
    this.el.createLabel.textContent = this.t("create");
    this.el.threadsTitle.textContent = this.t("threads");
    this.el.backToCategories.textContent = this.t("back");
    this.el.addThreadBtn.textContent = this.t("addThread");
    this.el.threadDialogTitle.textContent = this.t("newThread");
    this.el.threadTitleInput.placeholder = this.t("threadTitlePh");
    this.el.threadContentInput.placeholder = this.t("threadContentPh");
    if (this.el.threadTagsInput) this.el.threadTagsInput.placeholder = this.t("tagsPh");
    this.el.threadAuthorInput.placeholder = this.t("authorPh");
    this.el.cancelLabel2.textContent = this.t("cancel");
    this.el.publishLabel.textContent = this.t("publish");
    this.el.postsTitle.textContent = this.t("posts");
    this.el.backToThreads.textContent = this.t("back");
    this.el.addPostBtn.textContent = this.t("newPost");
    this.el.postDialogTitle.textContent = this.t("newPost");
    this.el.postContentInput.placeholder = this.t("threadContentPh");
    this.el.cancelLabel3.textContent = this.t("cancel");
    this.el.replyLabel.textContent = this.t("reply");
    this.el.footerText.textContent = this.t("footer");
    const year = new Date().getFullYear();
    const brand = this.t("title");
    this.el.copyrightText.textContent = this.t("copyright").replace("{year}", year).replace("{brand}", brand);
    this.el.loginTitle.textContent = this.t("loginTitle");
    this.el.loginEmail.placeholder = this.t("emailPh");
    this.el.loginPassword.placeholder = this.t("passwordPh");
    if (this.el.loginTotp) this.el.loginTotp.placeholder = this.t("twofaCodePh");
    this.el.loginCancel.textContent = this.t("cancel");
    this.el.loginSubmit.textContent = this.t("login");
    this.el.loginTitle.textContent = this.t("loginTitle");
    this.el.registerTitle.textContent = this.t("registerTitle");
    this.el.registerEmail.placeholder = this.t("emailPh");
    this.el.registerUsername.placeholder = this.t("usernamePh");
    this.el.registerPassword.placeholder = this.t("passwordPh");
    this.el.registerCancel.textContent = this.t("cancel");
    this.el.registerSubmit.textContent = this.t("register");
    this.el.adminTitle.textContent = this.t("adminPanel");
    this.el.adminCategoriesTitle.textContent = this.t("adminCategories");
    this.el.adminAddCategory.textContent = this.t("add");
    this.el.backAdminClose.textContent = this.t("close");
    this.el.adminCategoryName.placeholder = this.t("categoryNamePh");
    if (this.el.adminDiagSMTPBtn) this.el.adminDiagSMTPBtn.textContent = this.t("adminDiagSMTP");
    if (this.el.adminDiagDBBtn) this.el.adminDiagDBBtn.textContent = this.t("adminDiagDB");
    this.el.resetTitle.textContent = this.t("resetPassword");
    this.el.resetEmail.placeholder = this.t("emailPh");
    this.el.resetCancel.textContent = this.t("cancel");
    this.el.resetSubmit.textContent = this.t("send");
    this.el.performResetTitle.textContent = this.t("changePassword");
    this.el.performResetToken.placeholder = this.t("tokenPh");
    this.el.performResetPassword.placeholder = this.t("newPasswordPh");
    this.el.performResetCancel.textContent = this.t("cancel");
    this.el.performResetSubmit.textContent = this.t("save");
    this.el.searchInput.placeholder = this.t("searchPh");
    this.el.searchBtn.textContent = this.t("search");
    this.el.threadsPrev.textContent = this.t("prev");
    this.el.threadsNext.textContent = this.t("next");
    this.el.postsPrev.textContent = this.t("prev");
    this.el.postsNext.textContent = this.t("next");
    this.el.editThreadTitle.textContent = this.t("editThread");
    if (this.el.editThreadTagsInput) this.el.editThreadTagsInput.placeholder = this.t("tagsEditPh");
    this.el.editThreadCancel.textContent = this.t("cancel");
    this.el.editThreadSubmit.textContent = this.t("save");
    this.el.editPostTitle.textContent = this.t("editPost");
    this.el.editPostCancel.textContent = this.t("cancel");
    this.el.editPostSubmit.textContent = this.t("save");
    this.el.adminUsersTitle.textContent = this.t("users");
    this.el.profileTitle.textContent = this.t("profileTitle");
    this.el.profileUsername.placeholder = this.t("usernamePh");
    this.el.profileNotificationsLabel.textContent = this.t("notifications");
    if (this.el.enable2faBtn) this.el.enable2faBtn.textContent = this.t("enable2fa");
    if (this.el.disable2faBtn) this.el.disable2faBtn.textContent = this.t("disable2fa");
    if (this.el.twofaTitle) this.el.twofaTitle.textContent = this.t("twofaSetupTitle");
    if (this.el.twofaNote) this.el.twofaNote.textContent = this.t("twofaScanNote");
    if (this.el.twofaCode) this.el.twofaCode.placeholder = this.t("twofaCodePh");
    this.el.profileCancel.textContent = this.t("cancel");
    this.el.saveProfile.textContent = this.t("save");
    if (this.el.logoutAllBtn) this.el.logoutAllBtn.textContent = this.t("logoutAll");
    const opts = this.el.lang.querySelectorAll("option");
    opts.forEach(o => {
      if (o.value === "ru") o.textContent = "Русский";
      if (o.value === "kk") o.textContent = "Қазақша";
      if (o.value === "uk") o.textContent = "Українська";
      if (o.value === "bg") o.textContent = "Български";
      if (o.value === "en") o.textContent = "English";
    });
    this.updateDbBadge();
  },
  async restoreAuth() {
    if (!api.token) { this.updateHeaderAuth(); return }
    try {
      const me = await api.get("/api/me");
      this.state.user = me;
    } catch {
      api.setToken("");
      api.setRefreshToken("");
      this.state.user = null;
    }
    this.updateHeaderAuth();
  },
  updateHeaderAuth() {
    const logged = !!this.state.user;
    this.el.loginBtn.style.display = logged ? "none" : "";
    this.el.registerBtn.style.display = logged ? "none" : "";
    this.el.logoutBtn.style.display = logged ? "" : "none";
    this.el.userBadge.style.display = logged ? "" : "none";
    this.el.adminBtn.style.display = logged && this.state.user.role === "admin" ? "" : "none";
    this.el.profileBtn.style.display = logged ? "" : "none";
    this.el.userBadge.textContent = logged ? `${this.state.user.username} • ${this.state.user.role}` : "";
  },
  async refreshMeta() {
    try {
      const m = await api.get("/api/meta");
      this.state.meta = m;
      this.updateDbBadge();
      if (this.el.registerNote) {
        this.el.registerNote.textContent = m.smtp_ready ? this.t("registerNote") : this.t("smtpDisabledNote");
      }
      if (this.el.viewAdmin && !this.el.viewAdmin.classList.contains("hidden")) {
        const label = this.t("dbLabel");
        const mysql = this.t("dbMySQL");
        const json = this.t("dbJSON");
        const jsonFb = this.t("dbJSONFallback");
        const txt = m.mysql_ready ? `${label}: ${mysql} • ${m.mysql.host}:${m.mysql.port}/${m.mysql.db}` : (m.mode === "json_fallback" ? `${label}: ${jsonFb}` : `${label}: ${json}`);
        this.el.adminMeta.textContent = txt;
      }
    } catch {}
  },
  updateDbBadge() {
    const m = this.state.meta;
    if (!this.el.dbBadge) return;
    if (m && m.mysql_ready && m.mode === "mysql") {
      this.el.dbBadge.textContent = `${this.t("dbLabel")}: ${this.t("dbMySQL")}`;
      this.el.dbBadge.className = "badge badge-success";
      this.el.dbBadge.style.display = "";
      this.el.dbBadge.title = m.version || "";
    } else if (m) {
      this.el.dbBadge.textContent = `${this.t("dbLabel")}: ${this.t("dbJSON")}`;
      this.el.dbBadge.className = "badge badge-warning";
      this.el.dbBadge.style.display = "";
      this.el.dbBadge.title = m.version || "";
    } else {
      this.el.dbBadge.textContent = "";
      this.el.dbBadge.style.display = "none";
    }
  },
  connectWs() {
    try {
      const base = api.base || `${window.location.protocol}//${window.location.host}`;
      const wsUrl = base.replace(/^http:/, "ws:").replace(/^https:/, "wss:");
      const url = `${wsUrl.replace(/\/$/, "")}`;
      this.ws?.close?.();
      this.ws = new WebSocket(url);
      this.ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg && msg.type === "new_post" && msg.thread) {
            const title = msg.thread.title || "";
            const txt = (this.t("newPostInThread") || "New post").replace("{title}", title);
            if (this.el.searchMeta) {
              this.el.searchMeta.textContent = txt;
              setTimeout(() => { if (this.el.searchMeta.textContent === txt) this.el.searchMeta.textContent = ""; }, 5000);
            }
            if (this.state.current?.threadId && msg.thread.id === this.state.current.threadId) {
              // Refresh posts if currently viewing the thread
              this.renderPosts(this.state.current.threadId);
            }
          }
        } catch {}
      };
      this.ws.onclose = () => {
        setTimeout(() => this.connectWs(), 3000);
      };
    } catch {}
  },
  show(view) {
    this.el.viewCategories.classList.toggle("hidden", view !== "categories");
    this.el.viewThreads.classList.toggle("hidden", view !== "threads");
    this.el.viewPosts.classList.toggle("hidden", view !== "posts");
    this.el.viewAdmin.classList.toggle("hidden", view !== "admin");
  },
  render() {
    if (!this.el.viewCategories.classList.contains("hidden")) this.renderCategories();
    else if (!this.el.viewThreads.classList.contains("hidden")) this.renderThreads(this.state.current.categoryId);
    else if (!this.el.viewPosts.classList.contains("hidden")) this.renderPosts(this.state.current.threadId);
    else if (!this.el.viewAdmin.classList.contains("hidden")) this.renderAdmin();
  },
  renderCategories() {
    const ul = this.el.categoryList;
    ul.innerHTML = "";
    store.categories().then(categories => {
      if (!categories.length) {
        const li = document.createElement("li");
        li.textContent = this.t("empty");
        ul.appendChild(li);
        return;
      }
      categories.forEach(c => {
        const li = document.createElement("li");
        const left = document.createElement("div");
        left.innerHTML = `<div class="item-title">${escapeHtml(c.name)}</div>`;
        const actions = document.createElement("div");
        actions.className = "inline-actions";
        const openBtn = document.createElement("button");
        openBtn.className = "ghost";
        openBtn.textContent = this.t("threads");
        openBtn.addEventListener("click", () => {
          this.state.current.categoryId = c.id;
          this.show("threads");
          this.renderThreads(c.id);
        });
        actions.appendChild(openBtn);
        li.appendChild(left);
        li.appendChild(actions);
        ul.appendChild(li);
      });
    }).catch(err => {
      const li = document.createElement("li");
      li.textContent = this.t("apiError");
      ul.appendChild(li);
    });
  },
  renderThreads(categoryId) {
    const ul = this.el.threadList;
    ul.innerHTML = "";
    const q = this.el.searchInput.value.trim();
    const page = this.state.searchPage || 1;
    api.get(`/api/search/threads?q=${encodeURIComponent(q)}&categoryId=${encodeURIComponent(categoryId)}&page=${page}&size=10`)
      .then(res => {
        const list = res.items;
        this.el.searchMeta.textContent = `${res.page}/${res.pages} • ${res.total}`;
        if (!list.length) {
          const li = document.createElement("li");
          li.textContent = this.t("empty");
          ul.appendChild(li);
          return;
        }
        list.forEach(t => {
          const li = document.createElement("li");
          const left = document.createElement("div");
          const tags = (t.tags || []).map(x => `#${escapeHtml(x)}`).join(" ");
          left.innerHTML = `<div class="item-title">${escapeHtml(t.title)}${tags ? " • "+tags : ""}</div>
                            <div class="item-sub">${t.posts_count} ${this.t("postsCount")}</div>`;
          const actions = document.createElement("div");
          actions.className = "inline-actions";
          const openBtn = document.createElement("button");
          openBtn.className = "ghost";
          openBtn.textContent = this.t("posts");
          openBtn.addEventListener("click", () => this.openThread(t.id));
          actions.appendChild(openBtn);
        if (this.state.user && (this.state.user.role === "admin" || this.state.user.role === "moderator")) {
          const lockBtn = document.createElement("button");
          lockBtn.className = "ghost";
          lockBtn.textContent = t.locked ? this.t("unlock") : this.t("lock");
          lockBtn.addEventListener("click", () => {
            api.post(`/api/threads/${t.id}/lock`, { locked: !t.locked }).then(()=>this.renderThreads(categoryId));
          });
          const pinBtn = document.createElement("button");
          pinBtn.className = "ghost";
          pinBtn.textContent = t.pinned ? this.t("unpin") : this.t("pin");
          pinBtn.addEventListener("click", () => {
            api.post(`/api/threads/${t.id}/pin`, { pinned: !t.pinned }).then(()=>this.renderThreads(categoryId));
          });
          actions.appendChild(lockBtn);
          actions.appendChild(pinBtn);
        }
          if (this.state.user && (this.state.user.role === "admin" || this.state.user.role === "moderator")) {
            const editBtn = document.createElement("button");
            editBtn.className = "ghost";
            editBtn.textContent = this.t("edit");
            editBtn.addEventListener("click", () => {
              this.el.editThreadTitleInput.value = t.title;
              this.el.editThreadDialog.showModal();
              this.el.editThreadTagsInput.value = (t.tags || []).join(", ");
              this.el.editThreadForm.onsubmit = (e) => {
                e.preventDefault();
                const tags = this.el.editThreadTagsInput.value.split(",").map(s => s.trim()).filter(Boolean);
                api.post(`/api/threads/${t.id}/edit`, { title: this.el.editThreadTitleInput.value.trim(), tags })
                  .then(() => { this.el.editThreadDialog.close(); this.renderThreads(categoryId); })
                  .catch(err => alert(ui.t("apiError") + ": " + err.message));
              };
              this.el.editThreadCancel.onclick = () => this.el.editThreadDialog.close();
            });
            const delBtn = document.createElement("button");
            delBtn.className = "ghost";
            delBtn.textContent = this.t("delete");
            delBtn.addEventListener("click", () => {
              api.post(`/api/threads/${t.id}/delete`, {}).then(() => this.renderThreads(categoryId))
                .catch(err => alert(ui.t("apiError") + ": " + err.message));
            });
            actions.appendChild(editBtn);
            actions.appendChild(delBtn);
          }
          li.appendChild(left);
          li.appendChild(actions);
          ul.appendChild(li);
        });
      });
  },
  openThread(threadId) {
    this.state.current.threadId = threadId;
    this.show("posts");
    this.renderPosts(threadId);
  },
  renderPosts(threadId) {
    const ul = this.el.postList;
    ul.innerHTML = "";
    const page = this.state.postsPage || 1;
    api.get(`/api/threads/${threadId}/posts_paginated?page=${page}&size=10`).then(res => {
      const list = res.items;
      if (!list.length) {
        const li = document.createElement("li");
        li.textContent = this.t("empty");
        ul.appendChild(li);
        return;
      }
      list.forEach(p => {
        const li = document.createElement("li");
        const left = document.createElement("div");
        const date = new Date(p.created_at).toLocaleString(undefined, { dateStyle: "short", timeStyle: "short" });
        left.innerHTML = `<div class="item-title">${escapeHtml(p.author_username || "unknown")}</div>
                          <div class="item-sub">${date}</div>`;
        const content = document.createElement("div");
        content.innerHTML = renderMarkdownSafe(p.content);
        const actions = document.createElement("div");
        actions.className = "inline-actions";
        const likeBtn = document.createElement("button");
        likeBtn.className = "like-btn";
        const likeCount = (p.reactions || []).filter(r => r.type === "like").length;
        likeBtn.textContent = `${this.t("likes")}: ${likeCount}`;
        likeBtn.addEventListener("click", () => {
          api.post(`/api/posts/${p.id}/react`, { type: "like" }).then(r => { likeBtn.textContent = `${this.t("likes")}: ${r.count}`; });
        });
        actions.appendChild(likeBtn);
        if (this.state.user && (this.state.user.role === "admin" || this.state.user.role === "moderator" || this.state.user.username === p.author_username)) {
          const editBtn = document.createElement("button");
          editBtn.className = "ghost";
          editBtn.textContent = this.t("edit");
          editBtn.addEventListener("click", () => {
            this.el.editPostContentInput.value = p.content;
            this.el.editPostDialog.showModal();
            this.el.editPostForm.onsubmit = (e) => {
              e.preventDefault();
              api.post(`/api/posts/${p.id}/edit`, { content: this.el.editPostContentInput.value })
                .then(() => { this.el.editPostDialog.close(); this.renderPosts(threadId) })
                .catch(err => alert(ui.t("apiError") + ": " + err.message));
            };
            this.el.editPostCancel.onclick = () => this.el.editPostDialog.close();
          });
          const delBtn = document.createElement("button");
          delBtn.className = "ghost";
          delBtn.textContent = this.t("delete");
          delBtn.addEventListener("click", () => {
            api.post(`/api/posts/${p.id}/delete`, {}).then(() => this.renderPosts(threadId))
              .catch(err => alert(ui.t("apiError") + ": " + err.message));
          });
          actions.appendChild(editBtn);
          actions.appendChild(delBtn);
        }
        const att = document.createElement("div");
        att.className = "attachments";
        (p.attachments || []).forEach(a => {
          const img = document.createElement("img");
          img.src = a.url;
          img.alt = a.name || "image";
          att.appendChild(img);
        });
        li.appendChild(left);
        li.appendChild(content);
        li.appendChild(att);
        li.appendChild(actions);
        ul.appendChild(li);
      });
    });
  },
  renderAdmin() {
    this.el.adminCategoryList.innerHTML = "";
    this.refreshMeta();
    store.categories().then(categories => {
      categories.forEach(c => {
        const li = document.createElement("li");
        const left = document.createElement("div");
        left.innerHTML = `<div class="item-title">${escapeHtml(c.name)}${c.locked ? " • "+this.t("locked") : ""}</div>`;
        const actions = document.createElement("div");
        actions.className = "inline-actions";
        const editBtn = document.createElement("button");
        editBtn.className = "ghost";
        editBtn.textContent = this.t("edit");
        editBtn.addEventListener("click", () => {
          const name = prompt(this.t("edit"), c.name);
          if (!name) return;
          api.post(`/api/categories/${c.id}/edit`, { name }).then(()=>this.renderAdmin());
        });
        const delBtn = document.createElement("button");
        delBtn.className = "ghost";
        delBtn.textContent = this.t("delete");
        delBtn.addEventListener("click", () => {
          api.post(`/api/categories/${c.id}/delete`, {}).then(()=>this.renderAdmin());
        });
        const lockBtn = document.createElement("button");
        lockBtn.className = "ghost";
        lockBtn.textContent = c.locked ? this.t("unlock") : this.t("lock");
        lockBtn.addEventListener("click", () => {
          api.post(`/api/categories/${c.id}/lock`, { locked: !c.locked }).then(()=>this.renderAdmin());
        });
        actions.appendChild(editBtn);
        actions.appendChild(delBtn);
        actions.appendChild(lockBtn);
        li.appendChild(left);
        li.appendChild(actions);
        this.el.adminCategoryList.appendChild(li);
      });
    });
    this.el.adminAddCategory.onclick = () => {
      const name = this.el.adminCategoryName.value.trim();
      if (!name) return;
      store.addCategory(name)
        .then(() => { this.el.adminCategoryName.value = ""; this.renderAdmin(); })
        .catch(err => alert(this.t("apiError") + ": " + err.message));
    };
    api.get("/api/users").then(users => {
      this.el.adminUserList.innerHTML = "";
      users.forEach(u => {
        const li = document.createElement("li");
        const left = document.createElement("div");
        left.innerHTML = `<div class="item-title">${escapeHtml(u.username)} • ${u.role}</div>
                          <div class="item-sub">${escapeHtml(u.email)}${u.banned ? " • "+this.t("bannedLabel") : ""}${u.is_confirmed ? "" : " • " + this.t("emailUnconfirmed")}</div>`;
        const actions = document.createElement("div");
        actions.className = "inline-actions";
        const modBtn = document.createElement("button");
        modBtn.className = "ghost";
        modBtn.textContent = this.t("setModerator");
        modBtn.addEventListener("click", () => api.post(`/api/users/${u.id}/role`, { role: "moderator" }).then(()=>this.renderAdmin()));
        const userBtn = document.createElement("button");
        userBtn.className = "ghost";
        userBtn.textContent = this.t("setUser");
        userBtn.addEventListener("click", () => api.post(`/api/users/${u.id}/role`, { role: "user" }).then(()=>this.renderAdmin()));
        const adminBtn = document.createElement("button");
        adminBtn.className = "ghost";
        adminBtn.textContent = this.t("setAdmin");
        adminBtn.addEventListener("click", () => api.post(`/api/users/${u.id}/role`, { role: "admin" }).then(()=>this.renderAdmin()));
        const banBtn = document.createElement("button");
        banBtn.className = "ghost";
        banBtn.textContent = u.banned ? this.t("unban") : this.t("ban");
        banBtn.addEventListener("click", () => api.post(`/api/users/${u.id}/ban`, { banned: !u.banned }).then(()=>this.renderAdmin()));
        if (!u.is_confirmed) {
          const confirmBtn = document.createElement("button");
          confirmBtn.className = "ghost";
          confirmBtn.textContent = this.t("confirmEmail");
          confirmBtn.addEventListener("click", () => api.post(`/api/users/${u.id}/confirm`, {}).then(()=>this.renderAdmin()));
          actions.appendChild(confirmBtn);
        }
        actions.appendChild(modBtn);
        actions.appendChild(userBtn);
        actions.appendChild(adminBtn);
        actions.appendChild(banBtn);
        li.appendChild(left);
        li.appendChild(actions);
        this.el.adminUserList.appendChild(li);
      });
    }).catch(err => {
      this.el.adminMeta.textContent = `${this.t("apiError")}: ${err.message || err}`;
    });
  }
};
const captcha = {
  widgets: new Map(),
  mount(container, onSolved) {
    container.innerHTML = "";
    const canvas = document.createElement("canvas");
    const input = document.createElement("input");
    const actions = document.createElement("div");
    const refresh = document.createElement("button");
    const label = document.createElement("div");
    canvas.width = 240; canvas.height = 80;
    input.type = "text";
    actions.className = "inline-actions";
    refresh.className = "ghost";
    label.className = "item-sub";
    label.textContent = ui.t("captchaSolve");
    refresh.textContent = ui.t("captchaRefresh");
    actions.appendChild(refresh);
    container.appendChild(label);
    container.appendChild(canvas);
    container.appendChild(input);
    container.appendChild(actions);
    const draw = () => {
      const code = this.generate();
      this.widgets.set(container, { code, input });
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#0e0e17";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      for (let i=0;i<10;i++) {
        ctx.strokeStyle = `rgba(124,58,237,${Math.random()*0.7+0.1})`;
        ctx.beginPath();
        ctx.moveTo(Math.random()*240, Math.random()*80);
        ctx.bezierCurveTo(Math.random()*240, Math.random()*80, Math.random()*240, Math.random()*80, Math.random()*240, Math.random()*80);
        ctx.stroke();
      }
      ctx.font = "bold 36px Inter, Arial";
      for (let i=0;i<code.length;i++) {
        const ch = code[i];
        const x = 20 + i*40 + Math.random()*6;
        const y = 50 + Math.random()*10;
        const angle = (Math.random()*0.5 - 0.25);
        ctx.save();
        ctx.translate(x,y);
        ctx.rotate(angle);
        ctx.fillStyle = ["#a855f7","#7c3aed","#6d28d9","#f2f2f7"][i%4];
        ctx.fillText(ch, 0, 0);
        ctx.restore();
      }
      for (let i=0;i<60;i++) {
        ctx.fillStyle = `rgba(168,85,247,${Math.random()*0.8})`;
        ctx.fillRect(Math.random()*240, Math.random()*80, 2, 2);
      }
    };
    refresh.addEventListener("click", draw);
    draw();
  },
  generate() {
    const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let s = "";
    for (let i=0;i<5;i++) s += chars[Math.floor(Math.random()*chars.length)];
    return s;
  },
  verify(container) {
    const w = this.widgets.get(container);
    if (!w) return false;
    const ok = w.input.value.trim().toUpperCase() === w.code;
    return ok;
  }
};

function escapeHtml(s) {
  return s.replace(/[&<>"']/g, c => ({ "&":"&amp;", "<":"&lt;", ">":"&gt;", "\"":"&quot;", "'":"&#39;" }[c]));
}

function renderMarkdownSafe(md) {
  let s = escapeHtml(md);
  s = s.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  s = s.replace(/\*(.+?)\*/g, "<em>$1</em>");
  s = s.replace(/`(.+?)`/g, "<code>$1</code>");
  s = s.replace(/(?:\r?\n){2,}/g, "<br/><br/>");
  s = s.replace(/\r?\n/g, "<br/>");
  return s;
}
window.addEventListener("DOMContentLoaded", () => ui.init());
